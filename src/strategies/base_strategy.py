"""
Base strategy interface for all trading strategies.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Dict, Any, Optional, List
import pandas as pd


class SignalType(Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


@dataclass
class StrategySignal:
    """
    Represents a trading signal generated by a strategy.
    """
    signal_type: SignalType
    symbol: str
    confidence: float  # 0.0 to 1.0
    entry_price: float
    quantity: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    timestamp: datetime = None
    metadata: Dict[str, Any] = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()
        if self.metadata is None:
            self.metadata = {}

    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            'signal_type': self.signal_type.value,
            'symbol': self.symbol,
            'confidence': self.confidence,
            'entry_price': self.entry_price,
            'quantity': self.quantity,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'timestamp': self.timestamp.isoformat(),
            'metadata': self.metadata
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    """

    def __init__(self, name: str, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the strategy.

        Args:
            name: Strategy name
            config: Configuration parameters
        """
        self.name = name
        self.config = config or {}
        self.signals_generated = 0
        self.last_signal_time: Optional[datetime] = None

    @abstractmethod
    def generate_signal(
        self,
        symbol: str,
        market_data: Dict[str, Any],
        historical_data: Optional[pd.DataFrame] = None
    ) -> Optional[StrategySignal]:
        """
        Generate a trading signal based on market data.

        Args:
            symbol: Trading symbol
            market_data: Current market data
            historical_data: Historical price data

        Returns:
            StrategySignal if conditions are met, None otherwise
        """
        pass

    @abstractmethod
    def validate_signal(self, signal: StrategySignal) -> bool:
        """
        Validate a generated signal.

        Args:
            signal: Signal to validate

        Returns:
            True if signal is valid
        """
        pass

    def calculate_position_size(
        self,
        signal: StrategySignal,
        portfolio_value: float,
        risk_per_trade: float = 0.02
    ) -> float:
        """
        Calculate position size based on risk management.

        Args:
            signal: Trading signal
            portfolio_value: Current portfolio value
            risk_per_trade: Risk percentage per trade (default 2%)

        Returns:
            Position size (quantity)
        """
        if signal.stop_loss is None:
            # Default to 2% of portfolio if no stop loss
            return (portfolio_value * risk_per_trade) / signal.entry_price

        # Calculate based on stop loss distance
        risk_per_unit = abs(signal.entry_price - signal.stop_loss)
        if risk_per_unit == 0:
            return 0

        max_risk_amount = portfolio_value * risk_per_trade
        quantity = max_risk_amount / risk_per_unit

        return quantity

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate technical indicators.

        Args:
            df: DataFrame with OHLCV data

        Returns:
            DataFrame with added indicators
        """
        # This is a base implementation that can be overridden
        return df

    def get_stats(self) -> Dict[str, Any]:
        """Get strategy statistics."""
        return {
            'name': self.name,
            'signals_generated': self.signals_generated,
            'last_signal_time': self.last_signal_time.isoformat() if self.last_signal_time else None,
            'config': self.config
        }

    def _record_signal(self, signal: Optional[StrategySignal]):
        """Record that a signal was generated."""
        if signal is not None:
            self.signals_generated += 1
            self.last_signal_time = datetime.now()

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name={self.name}, signals={self.signals_generated})"
